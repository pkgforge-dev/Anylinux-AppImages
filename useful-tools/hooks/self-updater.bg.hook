#!/bin/sh

# Helper script in POSIX shell to self update appimages in place

# depends on appimageupdatetool which will be downloaded if not available

# simply make sure you have your AppRun call this script before starting the
# main application, that is all that's needed.

# you can set the var UPDATE_MSG to change the displayed update message

# this script should be ran in the background as it can take a few
# seconds to check for update

set -e

set -- "$APPDIR"/*.desktop
entry=${1##*/}
entry=${entry%.desktop}
UPDATE_POLICY_DIR=${UPDATE_POLICY_CONFIGDIR:-$HOST_XDG_CONFIG_HOME/auto-updates-policy}
UPDATE_POLICY_FILE=$UPDATE_POLICY_DIR/$entry-update-setting
APPNAME=${APPIMAGE##*/}

BINDIR=${XDG_BIN_HOME:-$HOME/.local/bin}
PATH="$PATH:$BINDIR"

WELCOME_MSG=${WELCOME_MSG:-Allow $APPNAME to check for updates? NOTE: We will download appimageupdatetool in $BINDIR if not available}
UPDATE_MSG="${UPDATE_MSG:-A new version of $APPNAME is available. Do you wish to update?}"
POST_UPDATE_GOOD="$APPNAME updated successfully!"
POST_UPDATE_BAD="ERROR: Something went wrong updating $APPNAME"
DO_NOT_ASK="Do you wish to disable update checking and not see this message again?"
APPIMAGEUPDATETOOL_LINK="${APPIMAGEUPDATETOOL_LINK:-https://github.com/AppImageCommunity/AppImageUpdate/releases/download/continuous/appimageupdatetool-$APPIMAGE_ARCH.AppImage}"

# check for other appimage managers
# skip appimaged/appimagelauncher because they cannot integrate DWARFS appimages
# we also do not check for gearlever because with gearlever the user
# has to be manually giving urls to update appimages which is terrible
# it is also not able to do delta updates at the time of writting this
_is_another_updater_here() {
	if [ "$DO_NOT_CHECK_FOR_OTHER_APPIMAGE_MANAGERS" != 1 ]; then
		if command -v am       \
		  || command -v appman \
		  || command -v dbin   \
		  || command -v soar; then
			return 0
		fi
	fi
	return 1
}

# make sure we can update the thing
_sanity_check() {
	if [ -f "$UPDATE_POLICY_DIR"/no_updatecheck ] \
	  || [ -f "$HOST_XDG_DATA_HOME"/appimagekit/no_updatecheck ]; then
		return 1
	elif [ "$DISABLE_AUTO_UPDATES" = 1 ]; then
		return 1
	elif [ -z "$APPIMAGE" ] || [ -z "$APPDIR" ]; then
		return 1
	elif [ ! -w "$APPIMAGE" ]; then
		>&2 echo "We cannot to overwrite $APPIMAGE due to lack of permissions"
		>&2 echo "This usually happens when the appimage is placed in /usr/bin"
		>&2 echo "or similar locations that need elevated rights to replace"
		return 1
	elif ! command -v notify; then
		return 1
	elif _is_another_updater_here; then
		return 1
	elif [ ! -d "$UPDATE_POLICY_DIR" ]; then
		mkdir -p "$UPDATE_POLICY_DIR"
	fi
}

_download() {
	url="$2"
	dest="$1"
	if ! notify -dq "Do you wish to download '$url' in '$dest'?"; then
		return 1
	elif command -v wget 1>/dev/null; then
		DOWNLOAD_CMD="wget"
		set -- -qO "$@"
	elif command -v curl 1>/dev/null; then
		DOWNLOAD_CMD="curl"
		set -- -Lso "$@"
	else
		>&2 echo "ERROR: We need wget or curl to download ${dest##*/}"
		notify -ne "We need wget or curl to download ${dest##*/}"
		exit 1
	fi
	if ! "$DOWNLOAD_CMD" "$@"; then
		>&2 echo "Something went wrong during download!"
		notify -ne "Something went wrong during download!"
		exit 1
	fi
}

_get_appimageupdatetool() {
	if command -v appimageupdatetool 1>/dev/null; then
		return 0
	fi
	mkdir -p "$BINDIR"
	if _download "$BINDIR"/appimageupdatetool "$APPIMAGEUPDATETOOL_LINK"; then
		chmod +x "$BINDIR"/appimageupdatetool
	else
		return 1
	fi
}

_check_update() {
	set +e
	appimageupdatetool -j "$APPIMAGE"
	status=$?
	set -e
	# exit code >1 likely indicates the app was not correctly packaged
	case "$status" in
		0) >&2 echo " $APPNAME is up to date"; return 1;;
		1) >&2 echo " $APPNAME update is available"; return 0;;
		*) >&2 echo " $APPNAME update check failed"; exit 0;;
	esac
}

_update() {
	if appimageupdatetool -Or "$APPIMAGE"; then
		>&2 echo "$POST_UPDATE_GOOD"
		notify "$POST_UPDATE_GOOD" 2>/dev/null || true
	else
		>&2 echo "$POST_UPDATE_BAD"
		notify "$POST_UPDATE_BAD" 2>/dev/null || true
	fi

}

_make_configfile() {
	if [ ! -f "$UPDATE_POLICY_FILE" ]; then
		echo "2" > "$UPDATE_POLICY_FILE"
		# do not ask the first time we are launched
		# because that just annoys people
		exit 0
	fi
}

_enable_update_checking() {
	echo "1" > "$UPDATE_POLICY_FILE"
}

_disable_update_checking() {
	echo "0" > "$UPDATE_POLICY_FILE"
}

# if check fails exit without error so that the app can still launch
_sanity_check 1>/dev/null || exit 0

# Make the configfile if it does not exist
_make_configfile

# Now read the file and determine what to do
read -r STATUS < "$UPDATE_POLICY_FILE"
if [ "$STATUS" = 0 ]; then
	>&2 echo "self updates disabled by $UPDATE_POLICY_FILE"
	exit 0
elif [ "$STATUS" = 1 ]; then
	if ! _get_appimageupdatetool; then
		if notify -dq "$DO_NOT_ASK"; then
			_disable_update_checking
		fi
	elif _check_update; then
		if notify -dq "$UPDATE_MSG"; then
			_update
		elif notify -dq "$DO_NOT_ASK"; then
			_disable_update_checking
		fi
	fi
else
	# wait 5 seconds before asking for the first time
	sleep 5
	if notify -dq "$WELCOME_MSG"; then
		_enable_update_checking
		_get_appimageupdatetool
	else
		_disable_update_checking
	fi
fi
